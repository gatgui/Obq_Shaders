<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
<title>Obq Arnold Shaders-Obq_Etching</title>
<meta http-equiv="Content-Language" content="en-us" />
<meta http-equiv="imagetoolbar" content="no" />
<meta name="MSSmartTagsPreventParsing" content="true" />
<meta name="description" content="Obq_Shaders for Arnold" />
<meta name="keywords" content="Obq_Shaders" />
<meta name="author" content="Marc-Antoine Desjardins - Oblique FX" />
<style type="text/css" media="all">@import "../css/master.css";</style>
</head>
<body>
<div id="page-container">
<div id="banner"><img src="../images/banner.jpg" alt="Banner"></div>
<div id="topMenu">
<div id="topMenu-left">
<a href="http://www.obliquefx.com"><img src="../images/oblique.png" alt="Oblique Logo" width = "150px"></a></div>
<div id="topMenu-right"><table border="0" cellpadding="9" cellspacing="0"><tr>
<td width="50"> </td>
<td><a href="../index.html">Home</a></td>
<td>|</td>
<td><a href="../news.html">News</a></td>
<td>|</td>
<td><a href="../documentation.html">Documentation</a></td>
<td>|</td>
<td><a href="../downloads.html">Downloads</a></td>
<td>|</td>
<td><a href="../about.html">About</a></td>
<td width="50"> </td>
</tr></table>
</div>
</div>
<div id="content">
<div id="content-sidebar">
<p align="left">Node Reference</p>
<table border="0" cellpadding ="2" cellspacing ="0">
<tr><td width="2"></td><td><a href="Obq_AngularCamera.html">Obq_AngularCamera</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_Atmosphere.html">Obq_Atmosphere</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_Bend4Stereo.html">Obq_Bend4Stereo</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_CameraProjectionSpace.html">Obq_CameraProjectionSpace</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_ChangeRange.html">Obq_ChangeRange</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_Color.html">Obq_Color</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_ColorspaceConverter.html">Obq_ColorspaceConverter</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_Environment.html">Obq_Environment</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_Etching.html">Obq_Etching</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_Fresnel.html">Obq_Fresnel</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_Fresnel2Standards.html">Obq_Fresnel2Standards</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_Hair.html">Obq_Hair</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_IESLightFilter.html">Obq_IESLightFilter</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_KettleUVStereoLens.html">Obq_KettleUVStereoLens</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_LensDistortion.html">Obq_LensDistortion</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_LightSaturationFilter.html">Obq_LightSaturationFilter</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_MeasuredMaterial.html">Obq_MeasuredMaterial</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_MessageGet.html">Obq_MessageGet</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_MessageSet.html">Obq_MessageSet</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_MessageStore.html">Obq_MessageStore</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_NodeInfo.html">Obq_NodeInfo</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_Opacity.html">Obq_Opacity</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_RandomColor.html">Obq_RandomColor</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_RandomID.html">Obq_RandomID</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_RayDepth.html">Obq_RayDepth</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_RGBComEmit.html">Obq_RGBComEmit</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_RGBComLightFilter.html">Obq_RGBComLightFilter</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_Root2Tip.html">Obq_Root2Tip</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_SetAlpha.html">Obq_SetAlpha</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_Shadow.html">Obq_Shadow</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_Simbiont.html">Obq_Simbiont</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_SpectrumColor.html">Obq_SpectrumColor</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_StereoLens.html">Obq_StereoLens</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_SurfaceEnvironment.html">Obq_SurfaceEnvironment</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_Thickness.html">Obq_Thickness</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_Toon.html">Obq_Toon</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_ToonSimple.html">Obq_ToonSimple</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_TransformShadingPoint.html">Obq_TransformShadingPoint</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_TransformUV.html">Obq_TransformUV</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_UVRemapLensDistortion.html">Obq_UVRemapLensDistortion</a></td></tr>
<tr><td width="2"></td><td><a href="Obq_VolumeThickness.html">Obq_VolumeThickness</a></td></tr>
</table>
</div>
<div id="content-help"><br>
<h2>Obq_Etching</h2>
<br>
<h5>Class</h5>
<p>Material</p>
<br>
<h5>Output</h5>
<p>Color RGB</p>
<br>
<h5>Synopsis</h5>
<p>A shader that somewhat creates an etching look. The orientation of the lines are define by UVs or any vectorial coordinates (the first 2 coordinates of any vector will be used). The number of lines are defined by a frequency and the thickness of the lines are defined by the <em>shading input</em>, normally a shader like the standard or Obq_Toon.</p>
<br>
<img src="images/Obq_Etching_01.jpg" alt="Synopsis image" width=768 >
<p class="idesc">Fig.1 : In this example, the Stanford Buddha and the background had a standard plugged into the shading input of Obq_Etching. UVs were used as coordinates for the Buddha, while a camera projection coordinates was used for the background (see the <em>Usage</em> section). Left is the shading input and right is the output.</p>
<p>To better illustrate what this shader does, take a look at the following images.</p>
<br>
<img src="images/Obq_Etching_03.jpg" alt="Synopsis image" width=768 >
<p class="idesc">Fig.2 : A)Texture coordinates. B) Shading input (a simple gradient in this case) . C) A remapped sine wave is used along the V axis of the object, thus making lines along the U axis. The intensity of the shading corresponds to the position of a virtual plane intersecting the wave. If the intensity of the shading is greater than the value of the sine at that V coordinate, then the bright color is used, else it's the dark color. D) The final output.</p>
<br>
<h5>Usage</h5>
<p>To work properly, Obq_Etching needs 2 external nodes for shading input and coordinates input. You should use a ray_switch in order to have Obq_Etching only evaluated by camera rays.</p>
<br>
<img src="images/Obq_Etching_02.jpg" alt="Usage image"  >
<p class="idesc">Fig.3 : Typical render tree for Obq_Etching.</p>
<br>
<hr/>
<h4>Bright</h4>
<br>
<img src="images/Obq_Etching_04.jpg" alt="Bright section" width=512 >
<p class="idesc">Fig.4 : A sphere with a spherical projection as coordinates. Top row images are the input shading left and Obq_Etching result right ( using white as <em>bright color</em>, 1.0 as <em>bright point</em>, black as <em>dark color</em> and 0.0 as <em>black point</em>. The lower row, from left to right : using an orange <em>bright color</em>, using a <em>bright point</em> of 0.5, enabling <em>multiply by normalized input</em> color.</p>
<br>
<h5>Bright Color <em>[bright_color]</em></h5>
<p>This is the color used when the value of the shading input is over the sine wave.</p>
<br>
<h5>Bright Point <em>[bright_point]</em></h5>
<p>This corresponds to the maximum value of the sine wave, meaning that when the shading input color reaches this value or higher, the <em>bright color</em> will be used no matter where you are in the period.</p>
<br>
<h5>Multiply by normalized input <em>[multiply_bright_color]</em></h5>
<p>If enabled, the <em>bright color</em> is multiplied by the shading input's normalized color.</p>
<p class="note" >Note : To determine the shading input's normalized color, an RGB to HSV conversion is done, the V value is then set to 1.0 and an HSV to RGB conversion is done.</p>
<br>
<hr/>
<h4>Dark</h4>
<br>
<img src="images/Obq_Etching_05.jpg" alt="Dark section" width=512 >
<p class="idesc">Fig.5 : A sphere with a spherical projection as coordinates. Using the same input shading as figure 4, these images correspond, from left to right and top to bottom : grey <em>dark color</em>, grey <em>dark color</em> and 0.25 as <em>dark point</em>, enabling </em>multiply by normalized input</em> color, same as previous but using a white <em>normalized black color</em> instead of black.</p>
<br>
<h5>Dark Color <em>[dark_color]</em></h5>
<p>This is the color used when the value of the shading input is over the sine wave.</p>
<br>
<h5>Dark Point <em>[dark_point]</em></h5>
<p>This corresponds to the minimum value of the sine wave, meaning that when the shading input color reaches this value or lower, the dark color will be used no matter where you are in the period.</p>
<br>
<h5>Multiply by normalized input <em>[multiply_dark_color]</em></h5>
<p>If enabled, the <em>dark color</em> is multiplied by the shading input's normalized color.</p>
<br>
<h5>Normalized black color <em>[normalized_black_color]</em></h5>
<p>Because a pure black color can't be properly normalized using the previously explained workflow, another parameter must be used to set what color should be used in this case.</p>
<br>
<hr/>
<h4>Signal</h4>
<br>
<h5>Frequency <em>[frequency]</em></h5>
<p>This is the number of period in the [0,1[ interval of UV.v values. A higher frequency means more lines and lower means less.</p>
<br>
<img src="images/Obq_Etching_06.jpg" alt="Frequency" width=768 >
<p class="idesc">Fig.6 : Three (3) different frequency values, from left to right : 10, 50 and 100.</p>
<br>
<h5>Offset <em>[offset]</em></h5>
<p>This parameter offsets the period of the sine wave, which results in a translation of the lines.</p>
<br>
<img src="images/Obq_Etching_07.jpg" alt="Offset" width=256 >
<p class="idesc">Fig.7 : A fractal is plugged into the <em>offset</em> port in order to bend the lines.</p>
<br>
<h5>Feather <em>[feather]</em></h5>
<p>This parameter somewhat blurs the edges.</p>
<br>
<img src="images/Obq_Etching_08.jpg" alt="Feather" width=768 >
<p class="idesc">Fig.8 : Three (3) different feather values, from left to right : 0, 0.5 and 1.</p>
<br>
<h5>Use linear wave type <em>[use_linear_signal]</em></h5>
<p>Instead of using a sine wave, this allows the use of triangle wave.</p>
<br>
<hr/>
<h4>Auto Filtering</h4>
<br>
<h5>Enable <em>[autoFiltering]</em></h5>
<p>High frequency patterns tend to create moir&eacute;s and other aliasing artefacts. Because of this, an auto-filtering option based on the UV screen space derivatives was implemented.</p>
<br>
<img src="images/Obq_Etching_09.jpg" alt="Auto-Filtering" width=768 >
<p class="idesc">Fig.9 : From left to right : no auto-filtering, auto-filtering enable, auto-filtering level.</p>
<br>
<h5>Show advanced options <em>[autoFilteringAdvanced]</em></h5>
<p>Because the settings were set empirically, checking this will open the options for manual tweaking.</p>
<br>
<h5>Show auto-filter level <em>[autoFilteringOut]</em></h5>
<p>This debug mode will enable you to see how much filtering is done (see figure 9).</p>
<br>
<h5>Apply to <em>[autoFilteringMode]</em></h5>
<p>This paramters allows you to choose what auto-filtering drives.</p>
<table borders="0" cellpadding=0 cellspacing=0 width=700>
<tr><td width=15> </td><td width=20 valign="top" align="center">&bull;</td><td valign="top" align="left" width="100"><span class="enumElem">Feather</span></td><td valign="top" align="center" width = 10>:</td><td valign="top" align="justify">the auto-filtering affects <em>feather</em> value.</td></tr>
<tr><td width=15> </td><td width=20 valign="top" align="center">&bull;</td><td valign="top" align="left" width="100"><span class="enumElem">Feather and Mix</span></td><td valign="top" align="center" width = 10>:</td><td valign="top" align="justify">the auto-filtering affects <em>feather</em> and <em>mix</em> values.</td></tr>
<tr><td width=15> </td><td width=20 valign="top" align="center">&bull;</td><td valign="top" align="left" width="100"><span class="enumElem">Mix</span></td><td valign="top" align="center" width = 10>:</td><td valign="top" align="justify">the auto-filtering affects <em>mix</em> value.</td></tr>
</table>
<br>
<h5>Also affected by U <em>[autoFilteringU]</em></h5>
<p>Because the lines are stacked up in the V axis, filtering based on V derivatives is more important. Enabling this will also use the U derivatives to control the level of auto-filtering.</p>
<br>
<h5>Bias <em>[autoFilteringBias]</em></h5>
<p>Bias control of level of auto-filtering.</p>
<br>
<h5>Gain <em>[autoFilteringGain]</em></h5>
<p>Gain control of level of auto-filtering.</p>
<br>
<h5>Range based on Frequency <em>[autoFilteringAutoRange]</em></h5>
<p>This allows the auto-filtering level to adapt to the <em>frequency</em>. For the same values of derivatives, a low frequency won't need as much filtering as a high frequency.</p>
<br>
<hr/>
<h4>Dots</h4>
<br>
<h5>Enable <em>[enable_dots]</em></h5>
<p>This option enables the use of dots in bright and dark values instead of lines.</p>
<br>
<img src="images/Obq_Etching_10.jpg" alt="Dots" width=512 >
<p class="idesc">Fig.10 : Top row from left to right : without dots, with dots enable. Bottom row from left to right : progressive dots bright = 0.9 and dark = 0.1, progressive dots bright = 0.75 and dark = 0.25.</p>
<br>
<h5>Dots appear progressively <em>[progressive_dots]</em></h5>
<p>Enables the bright dots to appear progressively in the dark lines and vice-versa.</p>
<br>
<h5>Bright dots start (ratio) <em>[bright_dots_start]</em></h5>
<p>From this intensity and up, bright dots start to appear in dark lines. The ratio means that we consider 0 the <em>dark point</em> and 1, the <em>bright point</em>.</p>
<br>
<h5>Dark dots start (ratio) <em>[dark_dots_start]</em></h5>
<p>From this intensity and down, dark dots start to appear in bright lines. The ratio means that we consider 0 the <em>dark point</em> and 1, the <em>bright point</em>.</p>
<br>
<hr/>
<h4>Input</h4>
<br>
<h5>Shading Input <em>[shading_input]</em></h5>
<p>This is the value that drives the thickness of the lines (ratio bright vs dark).</p>
<br>
<h5>Coordinates Input <em>[coordinates_input]</em></h5>
<p>This is the coordinates that drives the orientation of the lines. The lines are perpendicular to V axis in UV space (Y axis in XYZ).</p>
<p class="note" >Note : Only the first 2 coordinates (XY) of the vector will be used. If the dots are not enabled, than only Y is used.</p>
<br>
<h5>Use average RGB instead of luminance <em>[use_average_rgb]</em></h5>
<p>Normally, the shading input's luminance is used in order to make a scalar value out of the RGB. You can use the average intensities instead by enabling this.</p>
<br>
<h5>Mix <em>[mix]</em></h5>
<p>A linear interpolation mix between the etching result (0.0) and the shading input (1.0).</p>
<br>
<hr/>
<h4>AOVs</h4>
<p>Two (2) AOVs are also available : a grayscale matte of the bright component and the <em>shading input</em>.</p>
</div>
</div>
<div id="footer">Copyright &copy; 2011-2015, ObliqueFX. All Rights Reserved. </div>
</div>
</body>
</html>
